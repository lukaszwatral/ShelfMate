import { db } from '@/db/database';
import { initializeDatabase } from '@/db/init';
import { sql } from 'kysely';

export class BackupRepository {
  /**
   * Retrieves all data from database tables to create a backup object.
   * @returns {Promise<Object>} structured backup data containing version, timestamp and table rows.
   */
  async getDatabaseDump() {
    const [
      entities,
      tags,
      entityTags,
      files,
      codes,
      customFields,
      customFieldValues,
      settings,
      locales,
    ] = await Promise.all([
      db.selectFrom('Entity').selectAll().execute(),
      db.selectFrom('Tag').selectAll().execute(),
      db.selectFrom('EntityTag').selectAll().execute(),
      db.selectFrom('File').selectAll().execute(),
      db.selectFrom('Code').selectAll().execute(),
      db.selectFrom('CustomField').selectAll().execute(),
      db.selectFrom('CustomFieldValue').selectAll().execute(),
      db.selectFrom('Setting').selectAll().execute(),
      db.selectFrom('Locale').selectAll().execute(),
    ]);

    return {
      version: 1,
      timestamp: new Date().toISOString(),
      data: {
        Entity: entities,
        Tag: tags,
        EntityTag: entityTags,
        File: files,
        Code: codes,
        CustomField: customFields,
        CustomFieldValue: customFieldValues,
        Setting: settings,
        Locale: locales,
      },
    };
  }

  /**
   * Drops the current schema, re-initializes it, and populates it with backup data.
   * @param {Object} backupData - The data object generated by getDatabaseDump.
   */
  async restoreDatabase(backupData) {
    const { data } = backupData;

    // 1. Wipe existing data and schema
    await this.dropEntireSchema();

    // 2. Re-initialize empty tables
    await initializeDatabase();

    // 3. Populate with backup data
    await db.transaction().execute(async (trx) => {
      // Disable foreign keys to allow insertion in any order
      await sql`PRAGMA foreign_keys = OFF`.execute(trx);

      // Clear search index and autoincrement sequences
      await sql`DELETE FROM EntitySearch`.execute(trx);
      await sql`DELETE FROM sqlite_sequence`.execute(trx);

      // Restore User Data
      if (data.Entity?.length) await trx.insertInto('Entity').values(data.Entity).execute();
      if (data.Tag?.length) await trx.insertInto('Tag').values(data.Tag).execute();
      if (data.EntityTag?.length)
        await trx.insertInto('EntityTag').values(data.EntityTag).execute();
      if (data.File?.length) await trx.insertInto('File').values(data.File).execute();
      if (data.Code?.length) await trx.insertInto('Code').values(data.Code).execute();
      if (data.CustomField?.length)
        await trx.insertInto('CustomField').values(data.CustomField).execute();
      if (data.CustomFieldValue?.length)
        await trx.insertInto('CustomFieldValue').values(data.CustomFieldValue).execute();

      // Restore System Data (Clear defaults created by initializeDatabase first)
      if (data.Locale && data.Locale.length > 0) {
        await trx.deleteFrom('Locale').execute();
        await trx.insertInto('Locale').values(data.Locale).execute();
      }

      if (data.Setting && data.Setting.length > 0) {
        await trx.deleteFrom('Setting').execute();
        await trx.insertInto('Setting').values(data.Setting).execute();
      }

      // Re-enable foreign keys
      await sql`PRAGMA foreign_keys = ON`.execute(trx);
    });
  }

  /**
   * Completely wipes the database and re-initializes it to a fresh state.
   */
  async performFactoryReset() {
    try {
      await this.dropEntireSchema();
      await initializeDatabase();
    } catch (error) {
      console.error('Factory reset failed:', error);
      throw error;
    }
  }

  /**
   * Helper to drop all known tables in the system.
   */
  async dropEntireSchema() {
    await db.transaction().execute(async (trx) => {
      await sql`PRAGMA foreign_keys = OFF`.execute(trx);

      const tablesToDelete = [
        'EntityTag',
        'CustomFieldValue',
        'EntityFieldException',
        'File',
        'Code',
        'CustomField',
        'Tag',
        'Setting',
        'Locale',
        'Entity',
        'EntitySearch',
      ];

      for (const table of tablesToDelete) {
        await sql.raw(`DROP TABLE IF EXISTS "${table}"`).execute(trx);
      }

      await sql`DELETE FROM sqlite_sequence`.execute(trx);
      await sql`PRAGMA foreign_keys = ON`.execute(trx);
    });
  }
}

export const backupRepository = new BackupRepository();
